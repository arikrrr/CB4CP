This is an interactive problem.
Fox gave Cat two positive integers n n and k k . She has a hidden array a 1 , … , a n a 1 , … , a n of length n n , such that 1 ≤ a i ≤ n 1 ≤ a i ≤ n for every i i . Now they are going to play the following game:
For any two integers l , r l , r such that 1 ≤ l ≤ r ≤ n 1 ≤ l ≤ r ≤ n , define f ( l , r ) = ( r − l + 1 ) ⋅ max x = l r a x f ( l , r ) = ( r − l + 1 ) ⋅ max x = l r a x . In other words, f ( l , r ) f ( l , r ) is equal to the maximum of the subarray a l , … , a r a l , … , a r multiplied by its size.
Cat can ask Fox at most 2 n 2 n questions about the array. He will tell her two integers l l and x x ( 1 ≤ l ≤ n , 1 ≤ x ≤ 10 9 1 ≤ l ≤ n , 1 ≤ x ≤ 10 9 ), and she will tell him one integer p p as the answer — the smallest positive integer r r such that f ( l , r ) = x f ( l , r ) = x , or n + 1 n + 1 if no such r r exists.
Now, Cat needs to find the largest value m m such that there exists a sequence c 1 , … , c k − 1 c 1 , … , c k − 1 such that 1 ≤ c 1 < … < c k − 1 < n 1 ≤ c 1 < … < c k − 1 < n and f ( 1 , c 1 ) = f ( c 1 + 1 , c 2 ) = … = f ( c k − 1 + 1 , n ) = m f ( 1 , c 1 ) = f ( c 1 + 1 , c 2 ) = … = f ( c k − 1 + 1 , n ) = m . If no such m m exists, he should indicate this and take − 1 − 1 as the answer. Note that for k = 1 k = 1 , m m is always equal to f ( 1 , n ) f ( 1 , n ) .
In other words, the goal is to find the largest m m such that you can split the array into exactly k k subarrays ( k k is the constant given to you in the beginning of the interaction) so that all the subarrays have the product of their length and their maximum equal to m m , or determine that no such m m exists. Every element should belong in exactly one of the subarrays.
Cat doesn't know what he should do, so he asked you to play the game for him.
Each test contains multiple test cases. The first line contains a single integer t t ( 1 ≤ t ≤ 10 3 1 ≤ t ≤ 10 3 ) — the number of test cases. The description of the test cases follows.
The first line of each test case contains two positive integers n n and k k ( 1 ≤ k ≤ n ≤ 10 4 1 ≤ k ≤ n ≤ 10 4 ) — the length of the hidden array and the number of subarrays in the desired split.
Now you are allowed to make queries in the following way — print one line of the form " ? l x ? l x " (it must hold that 1 ≤ l ≤ n 1 ≤ l ≤ n , 1 ≤ x ≤ 10 9 1 ≤ x ≤ 10 9 ) and you will receive the smallest integer r r such that l ≤ r ≤ n l ≤ r ≤ n and f ( l , r ) = x f ( l , r ) = x , or n + 1 n + 1 if no such r r exists.
If you want to print the answer, output " ! m ! m " and you will recieve 1 1 if your answer is correct and − 1 − 1 otherwise. In the first case, the interaction continues with the next test case. Note that printing the answer doesn't count towards the number of queries made. Please note that you don't receive the values for the next test case immediately, you will first have to read whether your answer to the last test case was correct.
If you receive the integer − 1 − 1 at any moment, it means your program has made an invalid query, exceeded the query limit, or gave an incorrect answer. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.
After printing a query, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded . To do this, use:
It is guaranteed that the total sum of n n over the test cases won't exceed 10 4 10 4 .
Hacks
The format of the hacks should be the following: the first line should contain one integer t t ( 1 ≤ t ≤ 10 3 1 ≤ t ≤ 10 3 ) — the number of test cases. The description of the test cases should follow.
The first line of each test case should contain two integers n n and k k ( 1 ≤ k ≤ n ≤ 10 4 1 ≤ k ≤ n ≤ 10 4 ) — the length of the array a a and the number of subarrays you want to split it into.
The second line should contain n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ n 1 ≤ a i ≤ n ).
The sum of n n over all test cases should not exceed 10 4 10 4 .
The hidden arrays in the three testcases are [ 1 ] [ 1 ] , [ 1 , 2 ] [ 1 , 2 ] and [ 1 , 3 , 6 , 1 , 2 , 1 ] [ 1 , 3 , 6 , 1 , 2 , 1 ] . In the second testcase, no split satisfies the constraints, so the answer is − 1 − 1 .
The answer for the first query of the third testcase is 7 7 since no valid r r exists. For the second query of the third testcase, since 2 ⋅ max ( 1 , 3 ) = 6 2 ⋅ max ( 1 , 3 ) = 6 , we will get 2 2 as the answer, since r = 1 r = 1 doesn't satisfy the constraint.
The sample interaction guessed all three answers ( 1 , − 1 1 , − 1 and 6 6 ) correctly, so it received 1 1 after each answer.
