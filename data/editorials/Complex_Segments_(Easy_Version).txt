Let's write a functionmax_k(m), which returns the maximumkksuch that there exists a partition ofkkvalid sets containingmmintervals each.max_kworks inO(nlogn)O(nlog⁡n)in the following way (using a lazy segment tree):(wlog)ri≤ri+1ri≤ri+1;for eachiinot intersecting the previous subset, add11on the interval[l[i],r[i]][l[i],r[i]];as soon as a point belongs tommintervals, they become a subset;return the number of subsets.For a givenkk, you can binary search the maximummmsuch thatmax_k(m)≥k≥kinO(nlog2n)O(nlog2⁡n).The problem asks for the maximummkmk. Sincemk≤nmk≤n, for any constantCCeitherm≤Cm≤Cork≤n/Ck≤n/C. ForC=(nlogn)1/2C=(nlog⁡n)1/2, the total complexity becomesO((nlogn)3/2)O((nlog⁡n)3/2), which is enough to solve2018E1 - Complex Segments (Easy Version). You can also findmax_k(m)for allmmwith a divide and conquer approach, and the complexity becomesO(nn−−√logn)O(nnlog⁡n)(seehere).Now let's go back tomax_k(m). It turns out you can implement it inO(nα(n))O(nα(n)).First of all, let's make all the endpoints distinct, in such a way that two intervals intersect if and only if they were intersecting before.Let's maintain a binary string of sizenn, initially containing only ones, that can support the following queries:set bit in positionppto0;find the nearest1to the left of positionpp.This can be maintained with DSU, where the components are the maximal intervals containing100...00.Now let's reuse the previous solution (sweepingrrfrom left to right), but instead of a segment tree we will maintain a binary string with the following information:the positions>r>rstore1;the positions≤r≤rstore1if and only if the value in that position (in the previous solution) is a suffix max.So the queries become:add11to[l,r][l,r]:rrchanges, so you have to set elements in[r′+1,r−1][r′+1,r−1]to00;the only other element that changes is the nearest1to the left of positionll, which does not represent a suffix max anymore.find the maximum: it's equal to the number of suffix maximums, which depends onrrand on the number of components.This solution allows us to replace aO(logn)O(log⁡n)factor with aO(α(n))O(α(n))factor.Complexity:O(nn−−√α(n))O(nnα(n))[Bonus: there exists a data structure faster than DSU to solve the subproblem above, so you can solve the problem inO(nn−−√)O(nn). Seehere.]