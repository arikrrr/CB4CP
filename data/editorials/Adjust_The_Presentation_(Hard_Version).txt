2021C2 - Adjust The Presentation (Hard Version)Firstly, let's relabel thennmembers such that member numberiiis theii-th member in the initial line configuration in arrayaa. We also adjust the values inbb(and the future updates) accordingly.For now, let's solve the problem if there are no updates to the arraybb. Consider the first member who presents. Notice that member11must be the first one presenting since he/she is at the very front of the line, which meansb1=1b1=1must hold. After this, we insert him/her into any position in the line. However, instead of determining the target position immediately, we make member11a "pending member" and we will only determine his/her position later on when we need him/her again.To generalize, we can form an algorithm to check whether achievingbbis possible or not. We iterate each elementbibifor eachiifrom11tomm. While iterating, we maintain a set of pending members which is initially empty, and we maintain who is the next member in the line. When iterating a value ofbibi, there are three cases:Ifbibiis equal to the next member in the line, then we can make that member present. And then he/she will become a pending member for the next iterations.Else, ifbibiis one of the pending members, then we can always set a precise target position when moving that member in the past such that he/she will be at the very front of the line at this very moment. And then, that member will be a pending member again.Else, then it's impossible to make memberbibipresent at this time.To solve the problem with updates, let's observe some special properties ofbbifbbis valid. Notice that once a member becomes a pending member, he/she will be a pending member forever. And a memberxxbecomes a pending member during the first occurence of valuexxbb. Since the order of members becoming pending must follow the order of the members in the line, that means the first occurence for each valuexxinbbmust be in chronological order from11tonn. More formally, let's definefirst[x]first[x]as follows:If the valuexxappears at least once inbb, thenfirst[x]first[x]is the smallest indexiisuch thatbi=xbi=x.If the valuexxdoesn't appear inbb, thenfirst[x]=m+1first[x]=m+1.Then, forbbto be valid, it must hold thatfirst[1]≤first[2]≤…≤first[n]first[1]≤first[2]≤…≤first[n].To handle the updates, we must maintain the arrayfirstfirst. In order to do that, for each valuexxfrom11tonn, we maintain a set of indices for every occurence ofxxinbb. The value offirstfirstis just the minimum value in the set, orm+1m+1if the set is empty. An update to an element inbbcorresponds to two updates among the sets, which corresponds to two updates in arrayfirstfirst.To maintain the status on whether arrayfirstfirstis non-decreasing or not, we maintain a valueccwhich represents the number of pairs of adjacent indices(x,x+1)(x,x+1)(for all1≤x≤n−11≤x≤n−1) such thatfirst[x]≤first[x+1]first[x]≤first[x+1]. The array is non-decreasing if and only ifc=n−1c=n−1. For an update to an indexxxinfirstfirst, we only need to check how pairs(x−1,x)(x−1,x)and(x,x+1)(x,x+1)affect the value ofcc.Time complexity for each test case:O((n+m+q)log(n+m))O((n+m+q)log⁡(n+m))