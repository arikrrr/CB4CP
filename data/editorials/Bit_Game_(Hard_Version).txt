2027E1 - Bit Game (Easy Version)Each pile is an independent game, so let's try to find the nimber of a pile with valueaaand sizexx— let's denote this byf(x,a)f(x,a). Supposex=2k−1x=2k−1for some integerkk; in this case, the nimber is entirely dependent onaa. Ifxxis not in that form, consider the binary representation ofaa. If any bit inaais on wherexxis off, then it's equivalent to ifaahad that bit off, but all lower bits were on. Let's call such a bit a 'good bit'. So we can build some valuea′a′by iterating along the bits from highest to lowest; ifxxhas an on bit in this position, thena′a′will have an on bit in this position if and only ifaahas one there, or we've already found a good bit. Now that the bits ofxxanda′a′align, we can remove all zeros from both representations and it's clear that this is an equivalent game withx=2k−1x=2k−1.One small observation to make is that we can remove the ones inxxwhich correspond to leading zeros ina′a′, since we can never use these. So actually, after calculatinga′a′we only needg(a′)=f(2k−1,a′)g(a′)=f(2k−1,a′), wherekkis the smallest integer such that2k−1≥a′2k−1≥a′. By running a brute force using the Sprague–Grundy theorem to find the nimbers you can observe some patterns which encompass all cases:g(2k−2)=0g(2k−2)=0, for allk≥1k≥1.g(2k−1)=kg(2k−1)=k, for allk≥0k≥0.g(2k)=k⊕1g(2k)=k⊕1, for allk≥0k≥0.g(2k+1)=g(2k+2)=…=g(2k+1−3)=k+1g(2k+1)=g(2k+2)=…=g(2k+1−3)=k+1, for allk≥2k≥2.The first33cases are nice and relatively simple to prove, but the last is a lot harder (at least, I couldn't find an easier way). Anyway, I will prove all of them here, for completeness.First, note that if at any point we havex≤ax≤a, then we have a standard nim-game over thekkbits of the number, since we can remove any of them on each operation, so the nimber of such a game would bekk. The second case is one example of this; we havex=a=2k−1x=a=2k−1, so its nimber iskk.Now let's prove the first case. Whenk=1k=1,g(0)=0g(0)=0since there are no moves. For larger values ofkk, no matter which value ofddwe choose, the resulting game hasx≤ax≤awherexxhas a positive number of bits. Overall, we have themexmexof a bunch of numbers which are all positive, so the nimber is00as required.Now let's prove the third case. To reiterate, sincea′=2ka′=2kwe havex=2k+1−1x=2k+1−1by definition. This case is equivalent to having a nim-game with one pile ofkkbits (all bits below the most significant one), and another pile of11bit (the most significant one). This is because we can remove any amount from either pile in one move, but never both. Therefore, the nimber isk⊕1k⊕1as required.The last case is the hardest to prove. We need to show that there is some move that lands you in a game for all nimbers from00tokk, and never with nimberk+1k+1. Well, the only way that you could get a nimber ofk+1k+1is by landing in case33without changing the number of bits inxx/a′a′. Any move will change this though, since any move will remove some bits ofxxand whena′a′is recalculated it'll have fewer bits. Okay, now one way of getting a nimber of00is just by removing all bits inxxwhich are strictly after the first zero-bit ina′a′. For example, ifa′=101101a′=101101, then let's choosed=001111d=001111; then we'll land in case11. As for getting the rest of the nimbers from11tokk, it helps if we can just land in case22but with a varying number of bits. Ifa′≥2k+2k−1−1a′≥2k+2k−1−1this is easily possible by considering allddin the range2k≤d<2k+2k−12k≤d<2k+2k−1. On the other hand, ifa<2k+2k−1−1a<2k+2k−1−1, let's first consider the resulting value ofxxto be equal to2k+2m2k+2m, where2m2mis the lowest set bit ina′a′. This will give a nimber of22. Now, we can repeatedly add the highest unset bit in thisxxto itself to generate the next nimber until we now have all nimbers from22tokk. For the nimber of11, just have the resultingxxbe2k2k.Time complexity:O(nlogC)O(nlog⁡C), whereCCis the upper limit onxixi.