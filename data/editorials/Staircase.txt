There are two approaches to this problem: greedy and dynamic programming.Greedy approach. It's quite easy to see that we only have to consider broken steps, and repair them only once. So, we can consider each consecutive block of broken steps and solve the problem separately for it.If a block has even length, then there is only one way to repair it in the minimum possible number of days — repair the first and the second step on the same day, then the third and the fourth, and so on. So, for an even-length block, the total effort is the 2⋅∑ai2⋅∑ai.If a block has odd length, we can choose a step which will be left without a pair (so the effort for this step will not be doubled), and all the other steps will be paired. However, if we choose a step on an even position as a single step, it has an odd number of steps to the left and an odd number of steps to the right, so we cannot split them into pairs. So, we can choose a "single" step only among steps on odd positions from the block, and it's quite easy to see that the best step to choose is having the maximum aiai.Dynamic programming approach. Let dpidpi be a pair of two integers:When updating dynamic programming values, we try to minimize the first value, and to break ties, minimize the second value.The transitions are pretty straightforward:Both of these solutions can be implemented in O(n)O(n).