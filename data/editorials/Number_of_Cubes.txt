[problem:2040F]Recall Burnside's lemma — the number of elements up to an action group is:1|G|⋅∑g∈G∑x∈X[gx=x]1|G|⋅∑g∈G∑x∈X[gx=x], where[x]=1[x]=1ifx=truex=trueand[x]=0[x]=0ifx=falsex=false.Let's try to iterate over the elements of the action group — all triplets of numbers[0,a)[0,a),[0,b)[0,b),[0,c)[0,c). When applying a fixed action(i,j,l)(i,j,l), the element moves to this vector. Let's choose a cell and add a vector to it until we reach it again. We have drawn a cycle — all cells on it must be of the same type. An example of such a traversal for(a,b,c)=(9,4,1)(a,b,c)=(9,4,1),(i,j,k)=(3,2,0)(i,j,k)=(3,2,0)(each different number in the table corresponds to a cycle):123123123456456456123123123456456456You can count the cycles by traversal, or you can derive formula: the length of all cycles is the same and equalsN=lcm(agcd(a,i),bgcd(b,j),cgcd(c,l))N=lcm(agcd(a,i),bgcd(b,j),cgcd(c,l)).What's good about the equal lengths of the cycles? Because the formula for calculating the number of stationary parallelepipeds is simple. First, alldidimust be divisible byNN. Then we distribute them among the cycles. This is the multinomial coefficient for(d1N,d2N,…,dkN)(d1N,d2N,…,dkN).Current total timeO(a⋅b⋅c⋅k)O(a⋅b⋅c⋅k): iterated overa⋅b⋅ca⋅b⋅cvector triplets, calculatedNN, checked divisibility for allkknumbers, and if successful, calculated the multinomial coefficient of sizekk.Let's speed up the solution. Let's calculateG=gcd(d1,d2,…,dk)G=gcd(d1,d2,…,dk). Since alldidiare divisible byNN, thenGGis also divisible byNN. There are no more differentNNthan the number of divisors ofa⋅b⋅ca⋅b⋅c. Let's calculate the number of triplets that give each value ofNN, and at the end we will calculate the multinomial coefficient for all identical values ofNNat once.The total time isO(a⋅b⋅c⋅logC+d(a⋅b⋅c)⋅k)O(a⋅b⋅c⋅log⁡C+d(a⋅b⋅c)⋅k), whered(x)d(x)— is the number of divisors ofxx, andloglogappears due to the calculation ofgcdgcd.Let's continue to speed up the solution. There are two solutions further.Solution 1.Let's look again at the formulaN=lcm(agcd(a,i)…)N=lcm(agcd(a,i)…). For convenience, we will focus on the first element. Let's say we want the first element to bex=agcd(a,i)x=agcd(a,i). Thenxxis divisible byaaandax=gcd(a,i)ax=gcd(a,i).iiis divisible bygcd(i,…)gcd(i,…), soiiis divisible byaxax. Then the possibleiiare of the formp⋅axp⋅ax, where1≤p≤x1≤p≤x, and the equalitygcd(a,ax)=axgcd(a,ax)=axis exactly satisfied.ppis coprime toxx, otherwise the value ofgcdgcdwill be multiplied by their common divisor and the equality will be violated. Therefore the number of suitablexxis equal tophi(x)phi(x), wherephi(x)phi(x)— Euler's function.So, let's enumerate triplets of divisors ofaa,bbandcc. The number of ways to obtain a triple(x,y,z)(x,y,z)is equal tophi(x)⋅phi(y)⋅phi(z)phi(x)⋅phi(y)⋅phi(z). Let's calculatephi(x)phi(x)using the Sieve of Eratosthenes.We get a solution inO(d(a)⋅d(b)⋅d(c)⋅logC+d(a⋅b⋅c)⋅k)O(d(a)⋅d(b)⋅d(c)⋅log⁡C+d(a⋅b⋅c)⋅k)andO(a⋅b⋅c⋅loglog(a⋅b⋅c))O(a⋅b⋅c⋅log⁡log⁡(a⋅b⋅c))for pre-calculation.Solution 2.Let's calculate the sameNNusing dynamic programming. For convenience, we denote the dimensions ofaa,bb, andccby the arrayaiai. Letdp[i][j]dp[i][j]be the number of ways, having passediidimensions, to obtainlcmlcmequal tojj. The transitions will be as follows: we will iterate over the pairs of the previouslcmlcmt1t1and the next divisort2t2of the size of the next dimensionaiai. Then the newlcmlcmwill be equal tolcm(t1,t2)lcm(t1,t2)and we make the transitiondp[i+1][lcm(t1,t2)]+=dp[i][t1]⋅cnt[i][t2]dp[i+1][lcm(t1,t2)]+=dp[i][t1]⋅cnt[i][t2], wherecnt[i][j]cnt[i][j]— the number of suchxxthataigcd(ai,x)=jaigcd(ai,x)=j.How to calculate the arraycnt[i][j]cnt[i][j]. We cannot calculate it trivially inO((a+b+c)⋅logC)O((a+b+c)⋅log⁡C), since it is too long time. For simplicity, we calculate the arraycnt2[i][j]cnt2[i][j]equal to the number ofxxsuch thatgcd(ai,x)=jgcd(ai,x)=j. We iterate over the divisors ofaiaiin ascending order. Let the current divisor bed1d1. Addaid1aid1tocnt2[i][d1]cnt2[i][d1], since that manyxxwill be divisible byd1d1. Thosexxthat are divisible byd1d1but are not equal to it, we will subtract later. We iterate over the divisorsd2d2ofd1d1. We subtractcnt2[i][d1]cnt2[i][d1]fromcnt2[i][d2]cnt2[i][d2], since theirgcdgcdis actually notd2d2, butd1d1or a number thatd1d1divides. Let's calculatecnt[i][j]=cnt2[i][aij]cnt[i][j]=cnt2[i][aij].If we pre-calculate the divisors of all numbers and compress their "coordinates", we get a solution inO(d(a⋅b⋅c)2⋅logC+d(a⋅b⋅c)⋅k)O(d(a⋅b⋅c)2⋅log⁡C+d(a⋅b⋅c)⋅k).