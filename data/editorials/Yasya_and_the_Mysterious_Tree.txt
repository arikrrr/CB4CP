We will hang the tree on the vertex 11 and count for each vertex dvdv — xor on the path from it to the root. This can be done by depth-first traversal in O(n)O(n).Now let's learn how to solve the problem in O(n)O(n) for each query. The first type of query can be executed straightforwardly. Notice that due to the properties of the xor operation, the values will only change for vertices at odd depth (the depth of the root is 00). At the same time, they will change trivially: they will be xored with yy. To answer the second query, it is necessary to realize that the xor on a simple cycle v→lca(v,u)→u→vv→lca(v,u)→u→v is equal to dv⊕du⊕xdv⊕du⊕x. Indeed, the path from lca(v, u)lca(v, u) to the root will be counted twice, so it will turn into 00, and no other extra edges will be included in this xor. With due skill, you can try to speed up such a solution with AVX instructions, but the time constraints were chosen strictly.For a complete solution to the problem, you can use the data structure prefix tree (trie). With its help, you can find in O(logx)O(log⁡x) for the number xx such a yy in the set, that x⊕yx⊕y is maximal. Since dvdv change differently, you will have to use two tries — for vertices at even and odd heights. Operations of the first type can be accumulated in the variable woddwodd and added to the xor expression. In addition, you must not forget to remove dvdv from the necessary trie when answering the second query, and then insert it back. To do this, you can maintain a counter of terminal leaves in each vertex and use this information during descent.Thus, the final asymptotic is O((n+m)log109)O((n+m)log⁡109).