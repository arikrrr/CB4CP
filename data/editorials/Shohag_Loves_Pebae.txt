2039G - Shohag Loves PebaeLet's say we assignauauto the nodeuu. Lethuhube the maximum length of a simple path that passes throughuu. Then a necessary condition is thatauaucan not be a multiple of any number≤hu≤hu. Because ifauauis a multiple ofk≤huk≤huandvvis a node such that the unique simple path fromuutovvhas lengthkk, then the LCM of the values of the nodes fromuutovvis a multiple ofkk, which is a contradiction.The condition also means thatauaucan not be a multiple of any prime numberp≤hup≤hu.Is this a sufficient condition? Yes, and the proof is also simple.So now the problem is to count the number of assignments such that for each nodeuu,auauis not a multiple of any prime numberp≤hup≤huandgcd(a1,a2,…,an)=1gcd(a1,a2,…,an)=1.Letfw,pfw,pbe the count of numbers from11towwthat are not divisible by any prime≤p≤p,DDbe the diameter of the tree,A numberxxis good ifxxis not divisible by any prime≤D≤D,μ(g)μ(g)be the Mobius function,π(x)π(x)be the number of primes≤x≤x.Then the answer to our problem is∑mg=1μ(g)⋅[gis good]⋅∏ni=1f⌊mg⌋,hi∑g=1mμ(g)⋅[gis good]⋅∏i=1nf⌊mg⌋,hi.As⌊mg⌋⌊mg⌋is a non-decreasing function and has at most2m−−√2mdistinct values, we can iterate over⌊mg⌋⌊mg⌋and calculate range sums ofμ(g)⋅[gis good]μ(g)⋅[gis good].For calculating prefix sums of a multiplicative function (likeμ(g)μ(g)), it's a standard task and can be solved using Dirichlet convolution, Min25 sieve or multiple other methods.Here, we need a slight variant of the method as we need the prefix sums ofμ(g)⋅[gis good]μ(g)⋅[gis good]. This can be achieved using Dirichlet convolution inO(m2/3)O(m2/3)if we just imagine the prime numbers≤D≤Ddo not exist in the number system. Refer to my code for more details.But for each fixed⌊mg⌋⌊mg⌋, how do we calculate∏ni=1f⌊mg⌋,hi∏i=1nf⌊mg⌋,hifast enough? Trivially doing it will make the total complexity aroundO(nm−−√)O(nm)which is too slow.The key observation is to not forget that the values ofhihiare not random, they are the maximum length of a simple path that passes through the nodeii. Sohi≥⌈D2⌉hi≥⌈D2⌉for alliibecause from each node, the endpoints of the diameter are at least⌈D2⌉⌈D2⌉away.So now consider two cases:Case 1:D>2m−−√D>2mIn this case, allhi≥⌈D2⌉≥m−−√hi≥⌈D2⌉≥mfor allii. So only primes or11are the good numbers. So instead of going with the mobius route, we can just directly solve it by calculating the total number of ways and subtracting the number of ways where the gcd is a prime.We can calculate the total number of ways by first calculating the number of primes≤m≤mand thenfm,hifm,hiis justπ(m)−π(hi)+1π(m)−π(hi)+1.And the number of ways where the gcd is a prime is just11for all primes>D>Dand00otherwise.Counting primes undermmis also a standard task and can be done inO(m2/3logm)O(m2/3log⁡m)or faster.Case 2:D≤2m−−√D≤2mWe can convert eachhihito the maximum prime≤hi≤hiand then grouphihiby their values. Then the maximum number of groups will beO(π(m−−√))O(π(m)). So for each fixedk=⌊mg⌋k=⌊mg⌋, if the sum of the mobius function in the range(⌊mk+1⌋,⌊mk⌋](⌊mk+1⌋,⌊mk⌋]is non-zero (keep in mind that when all numbers in the range are bad numbers, then the sum will definitely be00), then we can calculate the product offk,hifk,hidirectly. Then the upper bound of the complexity will be aroundO(mlog2m⋅log(nπ(m√3)))O(mlog2⁡m⋅log⁡(nπ(m3))). The proof will be added later. This works fast enough.