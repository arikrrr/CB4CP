2028F - Alice's Adventures in AdditionLetdp[i][j]dp[i][j]be whethera1∘a2∘…∘ai=ja1∘a2∘…∘ai=jcan be satisfied. Then, let's case onaiai.Ifai=0ai=0, thendp[i][j]=dp[i−1][j]∨dp[i−2][j]∨⋯∨dp[0][j]dp[i][j]=dp[i−1][j]∨dp[i−2][j]∨⋯∨dp[0][j](where we will takedp[0][j]=1[j=0]dp[0][j]=1[j=0], the indicator thatj=0j=0). This is because we can multiply together any suffix to form00. We can do this in timeO(1)O(1)by keeping these prefix ORs.Ifai=1ai=1, thendp[i][j]=dp[i−1][j]∨dp[i−1][j−1]dp[i][j]=dp[i−1][j]∨dp[i−1][j−1](sincem≥1m≥1we don't have to worry about accidentally allowing00s). This is because we can either multiplyai−1ai−1by11or add11.Otherwise, note that we can only multiply together at mostlog2(j)log2⁡(j)manyai>1ai>1before the result exceedsjj. So, for eachiiletback(i)back(i)denote the biggestk<ik<isuch thatak≠1ak≠1. Then, we can writedp[i][j]=dp[i−1][j−ai]∨dp[back(i)−1][j−ai⋅aback(i)]∨⋯dp[i][j]=dp[i−1][j−ai]∨dp[back(i)−1][j−ai⋅aback(i)]∨⋯where we continue until we either reachi=0i=0, hit00, or exceedjj.There is one special case: ifak=0ak=0for anyk<ik<i, then we should also allowdp[i][j]|=dp[k−1][j]∨dp[k−2][j]∨⋯∨dp[0][j]dp[i][j]|=dp[k−1][j]∨dp[k−2][j]∨⋯∨dp[0][j]. We can keep track of the last timeak=0ak=0and use the same prefix OR idea as above.Note that all of these operations are "batch" operations: that is, we can do them for alljjsimultaneously for a givenii. Thus, this gives a bitset solution in timeO(nmlogmw)O(nmlog⁡mw)and with space complexityO(nmw)O(nmw). However, this uses too much space.We can optimize the space complexity to only storelog2(m)+4log2⁡(m)+4bitsets (with some extra integers) instead. To do this, note that for the00case we only require one bitset which we can update after eachii, for the11case we only have to keep the previous bitset, and for the>1>1case we only need to store the most recentlog2(m)log2⁡(m)bitsets for indicesiiwithai+1>1ai+1>1. We can keep this in a deque and pop from the back if the size exceedslog2(m)log2⁡(m). For the special case at the end, we can keep track of a prefix bitset for the last occurrence of a00.Overall, this uses space complexityO(mlog2mw)O(mlog2⁡mw)which is sufficient (interestingly, we don't even have to store the input!)