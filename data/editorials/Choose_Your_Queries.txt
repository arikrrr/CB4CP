2025F - Choose Your QueriesWe will use the classical method for solving maximization/minimization problems: we will come up with an estimate for the answer and try to achieve it constructively.The first idea. Since we havennobjects connected by binary relations, we can model the problem as a graph. Let thennelements of the array be the vertices, and theqqqueries be the edges. For each query, we would like to choose the direction of the edge (let the edge be directed towards the vertex to which the operation is applied) and the sign of the operation.It would be great if, in each connected component, we could choose an equal number of pluses and minuses so that the sum equals zero. Or, if the number of edges in the component is odd, to make the sum equal to one. Obviously, it is not possible to do less than this.It turns out that this is always possible. There is a well-known graph problem: to split the edges of an undirected connected graph into pairs with at least one common endpoint. We will reduce our problem to this one. If we split the graph into pairs, we will construct the answer from them as follows: we will direct the edges of each pair towards any common vertex, write+on the edge with the smaller number (query index), and write-on the edge with the larger number. This construction guarantees that each pair will not add anything to the sum, and each element will be non-negative after each query.The problem of splitting into pair can be solved using the following algorithm. We will perform a DFS from any vertex and construct a DFS tree. Now we will divide the edges into pairs in the order from the leaves to the root. Let us stand at some vertexvv. First, run the algorithm recursively for the children ofvv. When we finish processing the children, we will consider the following edges from the current vertexvv: tree edges to the children, the edge to the parent, and back edges with the lower endpoint atvv. Now, we form as many pairs as possible from the edges to the children and the back edges. We will remove all such edges from the graph. If their total number was odd, then one edge remains unpaired. Form a pair from it and the edge to the parent, and again remove them from the graph. It turns out that when we exit the recursive call, either there will be no edges left in the subtree at all, or there will be one tree edge that will be processed by the parent later. If the number of edges in the component is odd, then at the end, one edge without a pair will remain at the root.I would also like to mention the following implementation details. In the adjacency list, it is better to store the indices of the queries rather than the vertices, and then derive the vertex numbers from them. This will allow for careful handling of multiple edges. Removing edges from the graph directly is also not very convenient. The most convenient way to work around this, in my opinion, is to maintain an array that marks that the edge with such a query number is now removed. Alternatively, for back edges, we can check whethervvis the upper or lower endpoint, as well as return a flag from the depth-first search indicating "is the edge to the child removed".Overall complexity:O(n+q)O(n+q).