2021E3 - Digital Village (Extreme Version)Since the cost of a path uses the maximum edge weight in the path, we can use a Kruskal-like algorithm that is similar to finding the MST (Minimum Spanning Tree). Initially, the graph has no edges, and we add each edge one by one starting from the smallest values ofwiwi, while maintaining the connected components in the graph using DSU (Disjoint Set Union).While doing the MST algorithm, we simultaneously construct the reachability tree of the graph, whose structure represents the sequence of mergings of connected components in the algorithm. Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm. Each non-leaf vertex in the reachability tree always has two children, which are the two connected components that are merged to form the connected component represented by that vertex, so every time two connected components merge in the algorithm, we make a new vertex in the reachability tree that is connected to its two corresponding children.After doing all that, we've constructed a reachability tree that is a rooted binary tree with2n−12n−1vertices,nnof which are leaves. For each non-leaf vertexxx, we write downweight[x]weight[x]which is the weight of the edge that forms its connected component. For each leaf, we mark it as special if and only if it corresponds to a house that needs internet. Then, for each vertexxx, we calculatecnt[x]cnt[x], which is the number of special leaves in the subtree ofxx. These values will be used later.Consider a non-leafxxin the reachability tree. It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree ofxxcan have a path between them in the original graph with a weight of at mostweight[x]weight[x].Let's solve for some value ofkk. For each special vertexxx, we want to choose a target vertexyythat's an ancestor ofxx. Then, we choose a set ofkkleaves for the houses with installed servers. We want it such that each chosen target has at least one leaf in its subtree that is a member of the set. The total path cost of this is the sum ofweight[y]weight[y]for all chosen targetsyy.Let's say we've fixed the set ofkkleaves. Then, we mark every ancestor of these leaves. If we only consider the marked vertices with the edges between them, we have a reduced tree. For each special leaf, we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight.Knowing this, we can solve the problem in another point of view. Initially, we have the original reachability tree. We want to reduce it into a reduced tree withkkleaves. We want to do it while maintaining the chosen targets of the special leaves and their costs. Initially, for each special leaf, we choose itself as its target. In one operation, we can do the following:Choose a vertex that's currently a leaf.Move every target that's currently in that leaf to its parent.Remove that leaf and the edge connecting it to its parent.We want to do that until the reduced tree haskkleaves.For each edge connecting a vertexxxto its parentyyin the reachability tree, calculate(weight[y]−weight[x])×cnt[x](weight[y]−weight[x])×cnt[x]. That is the cost to move every target in vertexxxto vertexyy. Define that as the edge's length.We want to do operations with the minimum cost so that the reduced tree haskkleaves. We want to minimize the sum of lengths of the deleted edges. If we look at it in a different way, we want to choose edges to be in the reduced tree with the maximum sum of lengths.For some value ofkk, the edges of the reduced tree can be decomposed intokkpaths from some vertex to its descendant. We want the total sum of lengths of these paths to be as big as possible. But how do we solve it for everykkfrom11tonn?Let's sayk=1k=1. We can choose the path from the root to its furthest leaf. How do we solve fork=2k=2onwards? It turns out that we can use the optimal solution for some value ofkkto make the optimal solution fork+1k+1, by just adding the longest possible available path. That means, for eachkkfrom11tonn, we just find the current longest available path and add it to our reduced tree.What if at some point. there are more than one possible longest paths? It can be proven that we can choose any of these paths and the optimal solutions for the next values ofkkwill still be optimal.The proof for this greedy strategy involves the convexity of the total length askkgoes from11tonn. However, we won't explain it in detail here.So to solve the problem, we do DFS in the reachability tree to calculate for each vertexxx, the furthest leaf and the second furthest leaf in its subtree. For eachkkfrom11tonn, we add the current longest available path using this precalculation.Time complexity:O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)