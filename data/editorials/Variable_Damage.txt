2025G - Variable DamageLet's start unraveling the solution from the end. Suppose we currently havennheroes with healtha1,a2,…,ana1,a2,…,anandmmartifacts with durabilityb1,b2,…,bmb1,b2,…,bm. Let's assume we have already distributed the artifacts to the heroes, forming pairs(ai,bi)(ai,bi). Ifm>nm>n, we will discard the excess artifacts with the lowest durability. Ifm<nm<n, we will add the artifacts with durability00(that will deactivate at the start).How many rounds will the battle last? Notice the following: a hero with healthaaand an artifact with durabilitybbcan be replaced with two heroes with healthaaandmin(a,b)min(a,b), respectively, and the answer will not change.Thus, it is sufficient to analyze the case when there are no artifacts, and there are only heroes with healtha1,min(a1,b1),a2,min(a2,b2),…,an,min(an,bn)a1,min(a1,b1),a2,min(a2,b2),…,an,min(an,bn). The idea is as follows: in each round, the heroes take exactly11point of damage in total. Therefore, the battle will last∑i=1nai+∑i=1nmin(ai,bi)∑i=1nai+∑i=1nmin(ai,bi)rounds. The first sum is easy to maintain —let's focus on the second one.Next, we need to learn how to distribute the artifacts in such a way that maximizes this sum. Intuitively, it seems that the healthiest heroes should receive the most durable artifacts. That is, we should sort the heroes in descending order of health and the artifacts in descending order of durability.We will show that this is indeed the case. Suppose there are two heroes with healtha1a1anda2a2(a1≥a2a1≥a2). They receive artifacts with durabilityb1b1andb2b2(b1≥b2b1≥b2). We will show that it is optimal to give the first artifact to the first hero and the second one to the second hero. If there is at least one artifact with durability not greater thana2a2(that is, the minimum will always be equal to this artifact), it is always optimal to give it to the second hero and the other artifact to the first hero. If there is at least one artifact with durability not less thana1a1(that is, the minimum will always be equal to the hero), it is always optimal to give it to the first hero. Otherwise, the durabilities of the artifacts lie between the health values of the heroes, meaning that the minimum for the first hero will always be equal to his artifact, and the minimum for the second hero will be his health. Therefore, it is again optimal to give the larger artifact to the first hero. It follows that if for a pair of heroes the condition that the larger hero has the larger artifact is not met, we can swap their artifacts, and the answer will not decrease.Thus, the task is as follows. After each query, we need to maintain a sorted sequence of heroes, artifacts, and the summin(ai,bi)min(ai,bi). This sounds quite complicated because there are a lot of changes with each query. Some suffix of one of the arrays shifts one position to the right after inserting a new element, affecting many terms.Let's consider an idea of a sweep line instead. We will combine the heroes and artifacts into one array and sort it in descending order. For simplicity, let's assume all durability and health values are distinct integers. Then we will iterate over this array while maintaining the number of heroes who have not yet received an artifact and the number of artifacts that have not been assigned to a hero. If we encounter an artifact and there are previously encountered heroes who have not received an artifact, we will give this artifact to any of them. Since all these heroes have health greater than the durability of this artifact, the minimum will always be equal to the durability of the artifact. Thus, the sum will increase by the durability of the artifact. Otherwise, we will remember that there is one more free artifact. The same goes for a hero. If we encounter a hero and there are previously encountered artifacts that have not been assigned to a hero, we will give any of these artifacts to the hero. The sum will then increase by the hero's health.It can be shown that this process of assigning artifacts yields the same result as sorting.Note that at any moment of time, there are either no free heroes or no free artifacts. Thus, it is sufficient to maintain a "balance" —the difference between the number of heroes and artifacts on the prefix. If the balance is positive, and we encounter an artifact, we add its durability to the answer. If the balance is negative, and we encounter a hero, we add his health to the answer.Note that equal elements do not break this algorithm. For simplicity, I suggest sorting not just the values but pairs of values and query indices to maintain a strict order.How does this reduction help? It turns out that it is now possible to use square root decomposition to solve the problem.Read all queries in advance and sort them by the value(vi,i)(vi,i)in descending order. We will divide all queries into blocks of sizeBB. Initially, all queries are deactivated. When processing the next query in the input order, we will activate it within the block and recalculate the entire block.What should we store for each block? Notice that all balance checks for the terms depend on two values: the balance at the start of the block and the balance before this term within the block. Therefore, for the block, we can maintain the following values: the total balance in the block, as well as the total contribution of the terms from this block for each balance at the start of the block. Obviously, the balance at the start of the block can range from−q−qtoqq. However, if the absolute value of the balance exceedsBB, the contribution of the block will be the same as if this balance was limited by−B−BorBB, respectively (since within the block it will either always be positive or always negative). Thus, it is sufficient to calculate the answer only for balances from−B−BtoBB.Knowing these values for each block, the answer can be calculated inO(qB)O(qB). We will go through the blocks while maintaining the current balance. We will add the block's contribution for the current balance to the answer and add the total balance of the block to the current balance.We still need to learn how to quickly recalculate the answers for all balances within the block. We will iterate over the elements within the block while maintaining the current balance inside the block. Let the balance bekk. Then if the current element is an artifact, its durability will be added to the sum if the balance at the start of the block is at least−k+1−k+1. Similarly, if the current element is a hero, his health will be added if the balance at the start of the block is at most−k−1−k−1. Thus, we need to add a value over some range of balances—either from−k+1−k+1toBB, or from−B−Bto−k−1−k−1. This can be done using a difference array. That is, we can make two updates inO(1)O(1)for each element of the block, and then compute the prefix sum once inO(B)O(B).Therefore, for each query, we can update the structure inO(B)O(B), and recalculate the sum inO(qB)O(qB). Hence, it is optimal to chooseB=q√B=q.Overall complexity:O(qq√)O(qq).