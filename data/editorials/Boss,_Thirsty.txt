2021D - Boss, ThirstyWe can see it as a grid of square tiles, consisting ofnnrows andmmcolumns. Consider a single row. Instead of looking at themmtiles, we can look at them+1m+1edges between tiles, including the leftmost edge and the rightmost edge. We number the edges from00tommsuch that tilejj(1≤j≤m1≤j≤m) is the tile between edgej−1j−1and edgejj.For a single rowii, choosing a segment of tiles is equivalent to choosing two different edgesllandrr(0≤l<r≤m0≤l<r≤m) as the endpoints of the segment, which denotes choosing the tiles froml+1l+1torr. For each edgejj, we can precompute a prefix sumpref[j]=Ai,1+Ai,2+…+Ai,jpref[j]=Ai,1+Ai,2+…+Ai,j. That means, choosing edgesllandrryields a profit ofpref[r]−pref[l]pref[r]−pref[l].Let's say we've chosen edgesl′l′andr′r′for rowi−1i−1and we want to choose two edgesllandrrfor rowiithat satisfies the problem requirement. We want to choose a continuous segment that includes at least one chosen tile and at least one unchosen tile from the previous row. A chosen tile that is adjacent to an unchosen tile only appears at the endpoints of the previous segment. That means, to satisfy the requirement, the new segment must strictly contain at least one endpoint of the previous segment. More formally, at least one of the following conditions must be satisfied:l<l′<rl<l′<rl<r′<rl<r′<rKnowing that, we can see that when going from one row to the next, we only need the information for one of the two endpoints, not both.We can solve this with dynamic programming from row11to rownn. For each row, we find the optimal profit for eachlland the optimal profit for eachrr. We do those two things separately. For each rowii, define the following things:dpL[i][l]dpL[i][l]: the optimal profit for the firstiirows if the left endpoint of the last segment isll.dpR[i][r]dpR[i][r]: the optimal profit for the firstiirows if the right endpoint of the last segment isrr.Let's say we've calculated all values ofdpLdpLanddpRdpRfor rowi−1i−1and we want to calculate for rowii. Letllandrrbe the left and right endpoints of the new segment respectively. Letppbe one of the endpoints of the previous segment. Then it must hold thatl<p<rl<p<r, which yields a maximum profit of−pref[l]+max(dpL[i−1][p],dpR[i−1][p])+pref[r]−pref[l]+max(dpL[i−1][p],dpR[i−1][p])+pref[r].Let's calculate all values ofdpRdpRfirst for rowii. For eachrr, we want to consider all corresponding triples(l,p,r)(l,p,r)and find the maximum profit among them. In order to do that, we do three steps:Make a prefix maximum of−pref[l]−pref[l].Then, for eachpp, we addmax(dpL[i-1][p],dpR[i−1][p])max(dpL[i-1][p],dpR[i−1][p])with the maximum value of−pref[l]−pref[l]for all0≤l<j0≤l<j. And then we make a prefix maximum of those values.Then, for eachrr, the value ofdpR[i][r]dpR[i][r]ispref[r]pref[r]added by the maximum value for the previous calculation for eachppfrom00tor−1r−1.We do the same thing fordpLdpLbut we use suffix maxmiums instead.After doing all that for every row from11tonn, we find the maximum value ofdpLdpLanddpRdpRin the last row to get the answer.Time complexity of each test case:O(nm)O(nm)