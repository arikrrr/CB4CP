As given in the problem statement, the definition of a beautiful array is not very interesting to us, since checking the beauty of an array is quite complex. Let's try to simplify it.First of all, the first and last elements will never be changed, as it is impossible to choose such ii for operations. If they are different, then the array is definitely not beautiful. Moreover, if the array is beautiful, then all its elements at the end will be equal to the first and the last elements.The second idea is a bit more complicated. Notice that each element can be changed at most once. Consider an arbitrary operation. We choose some ii for which ai−1=ai+1ai−1=ai+1, and change aiai to ai−1ai−1. Now both ai−1ai−1 and ai+1ai+1 will always remain equal to their current values, because in any operation involving them, aiai will also be involved. This means that aiai will also remain equal to the new value.The next idea is as follows. We know what all the elements should be equal to in the end. This means that we need to apply operations to all elements that are not equal to this value. According to the previous idea, this is possible if and only if there are no two consecutive numbers in the array that are not equal to this value. The sufficiency of this condition is obvious, and the necessity is left as an exercise to the reader.In other words, the check looks like this: a1=ana1=an, and ai=a1ai=a1 or ai+1=a1ai+1=a1 (or both are equal) for all ii.What elements should be removed so that the check does not pass? There are two options: break the first or second condition. So, you can do the following:The third condition can be simplified. If other numbers not equal to a1a1 are encountered between the selected numbers, then another pair can be chosen, for which fewer numbers have to be removed. Therefore, it is only optimal to choose a pair for which all the numbers between them are equal to a1a1.Then the solution is as follows. Find the shortest block of numbers equal to a1a1. Remove it from the array. It can be at the prefix or at the suffix — then the first condition will be broken. Or it can be somewhere in the middle — then the second condition will be broken.To find such a block, you can go through the array from left to right, maintaining the position of the previous element not equal to a1a1. If the current element is not equal to a1a1, update the answer with the difference between the saved and current positions, and update the saved position.The only case when the answer is -1 is when all the elements of the array are the same. Otherwise, it is always possible to make the array not beautiful.Overall complexity: O(n)O(n) for each testcase.