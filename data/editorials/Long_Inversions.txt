No substring of the string needs to be inverted twice, as it does not change the string in any way. Let's fix kk and try to check if all the characters of the string can be made equal to 1. Suppose the first ii characters are already equal to 1, and si+1=0si+1=0. Then we need to invert all the bits starting from the i+1i+1-th to the i+ki+k-th inclusive, i.e., not invert the first ii characters. If we invert any of the first ii characters, then we will have to invert it again. Either we will invert si+1si+1 again, so it will become equal to 0, or we will invert the characters to the left and come to the same situation, but for a smaller prefix.Naive checking for a fixed kk takes O(n⋅k)O(n⋅k) time, if we honestly invert kk characters every time we encounter 0. We will maintain an inversion counter — how many times we need to invert a character of the string. Getting the actual value of a character is simple — if the counter is odd, invert the character. If si=0si=0, add 11 to the counter, and remember that we need to subtract 11 from the counter after position i+ki+k, forming a segment [i,i+k)[i,i+k). This way, the complexity of the check will be O(n)O(n).It remains to iterate over kk and find the maximum for which it was possible to bring the string to all 1s. The complexity of the solution is O(n2)O(n2).